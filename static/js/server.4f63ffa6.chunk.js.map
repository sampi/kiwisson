{"version":3,"sources":["server/server.js"],"names":["__webpack_require__","r","__webpack_exports__","d","numsToText","_constants__WEBPACK_IMPORTED_MODULE_0__","wordMap","Map","input","arguments","length","undefined","split","map","inWord","rawInput","join","output","num","parseInt","keys","subtitle","filter","Boolean","reduce","possibleWords","currentLetters","combinations","currentLetter","letter","concat","possibleMatch","has","sort","a","b","get","exec","processWord","e","console","error","then","bind","_ref","words","forEach","word","frequency","set"],"mappings":"yFAAAA,EAAAC,EAAAC,GAAAF,EAAAG,EAAAD,EAAA,+BAAAE,IAAA,IAAAC,EAAAL,EAAA,GAQA,IAAIM,EAAU,IAAIC,IAoEX,SAASH,IAAuB,IAAZI,EAAYC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAJ,GAClC,IACC,OAAOD,EACLI,MAAM,KACNC,IAAIC,IA3DR,WAAoC,IAAfC,EAAeN,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAJ,GAE/B,MAAMD,EAAQO,EAASH,MAAM,KAAKI,KAAK,IAGjCC,EAELT,EACEI,MAAM,IAENC,IACAK,IACEA,EAAMC,SAASD,EAAK,MACrBA,GAAO,GACPA,GAAO,GACPE,IAAKF,EAAM,GAAGG,SAAST,MAAM,KAG9BU,OAAOC,SAGPC,OACA,CAACC,EAAeC,IACfD,EAAcD,OACb,CAACG,EAAcC,IACdF,EACEb,IAAIgB,GAAUD,EAAgBC,GAC9BC,OAAOH,GACV,IAEF,CAAC,KAGDL,OAAOS,GAAiBzB,EAAQ0B,IAAID,IAEpCE,KAAK,CAACC,EAAGC,IAAM7B,EAAQ8B,IAAIF,GAAK5B,EAAQ8B,IAAID,IAG/C,OAAKlB,EAAOP,OASLO,EAJO,kBAAkBoB,KAAKtB,GAAU,GAAGL,OAI5BO,EAAOP,QARrBF,GAoBS8B,CAAYxB,IAC1BE,KAAK,KACN,MAAOuB,GAER,OADAC,QAAQC,MAAMF,GACP,IA1ETvC,EAAAuC,EAAA,GAAAG,KAAA1C,EAAA2C,KAAA,UAAkDD,KAAKE,IAAA,OAAAA,EAAGC,MACnDC,QAAQ,CAACC,EAAMC,IAAc1C,EAAQ2C,IAAIF,EAAMC","file":"static/js/server.4f63ffa6.chunk.js","sourcesContent":["import { keys } from '../constants';\n\n/**\n * Available dictionary of words,\n * key - word\n * value - frequency of use in English\n * @type {Map<String, Number>}\n */\nlet wordMap = new Map();\n// Build Map of words and frequencies\nimport(/* webpackChunkName: \"words\" */ './words').then(({ words }) =>\n\twords.forEach((word, frequency) => wordMap.set(word, frequency))\n);\n\n/**\n * Process a single word\n * Find matches in the dictionary and return one match,\n * If there are no matches, return the input\n * @param  {String} rawInput Raw input, including * characters\n * @return {String}          Processed word\n */\nfunction processWord(rawInput = '') {\n\t// Normalize input by removing all * characters\n\tconst input = rawInput.split('*').join('');\n\n\t// Find matching words from the dictionary\n\tconst output =\n\t\t// Split input in an Array of numbers\n\t\tinput\n\t\t\t.split('')\n\t\t\t// Map each number to an Array of letters\n\t\t\t.map(\n\t\t\t\tnum =>\n\t\t\t\t\t(num = parseInt(num, 10)) &&\n\t\t\t\t\tnum >= 2 &&\n\t\t\t\t\tnum <= 9 &&\n\t\t\t\t\tkeys[num - 1].subtitle.split('')\n\t\t\t)\n\t\t\t// Filter out empty elements\n\t\t\t.filter(Boolean)\n\t\t\t// Find all possible permutations of each Array of letters\n\t\t\t// by reducing all possible letters to be added to all of the words\n\t\t\t.reduce(\n\t\t\t\t(possibleWords, currentLetters) =>\n\t\t\t\t\tpossibleWords.reduce(\n\t\t\t\t\t\t(combinations, currentLetter) =>\n\t\t\t\t\t\t\tcurrentLetters\n\t\t\t\t\t\t\t\t.map(letter => currentLetter + letter)\n\t\t\t\t\t\t\t\t.concat(combinations),\n\t\t\t\t\t\t[]\n\t\t\t\t\t),\n\t\t\t\t['']\n\t\t\t)\n\t\t\t// Filter out words that aren't in the dictionary\n\t\t\t.filter(possibleMatch => wordMap.has(possibleMatch))\n\t\t\t// Sort them based on frequency\n\t\t\t.sort((a, b) => wordMap.get(a) - wordMap.get(b));\n\n\t// If there aren't any matches, return the input string\n\tif (!output.length) {\n\t\treturn input;\n\t}\n\n\t// Find the number of trailing * characters\n\tconst stars = /[0-9]+([*]*)$/gi.exec(rawInput)[1].length;\n\n\t// Return the matched word,\n\t// or alternative match\n\treturn output[stars % output.length];\n}\n\n/**\n * Turn a string of numbers and *'s into words\n * @param  {String} input Input numbers and *'s\n * @return {String}       Output words\n */\nexport function numsToText(input = '') {\n\ttry {\n\t\treturn input\n\t\t\t.split('0')\n\t\t\t.map(inWord => processWord(inWord))\n\t\t\t.join(' ');\n\t} catch (e) {\n\t\tconsole.error(e);\n\t\treturn '';\n\t}\n}\n"],"sourceRoot":""}