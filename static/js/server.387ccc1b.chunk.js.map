{"version":3,"sources":["server/server.js"],"names":["__webpack_require__","r","__webpack_exports__","d","numsToText","_constants__WEBPACK_IMPORTED_MODULE_0__","wordMap","input","arguments","length","undefined","split","map","inWord","rawInput","join","re","RegExp","concat","num","parseInt","keys","subtitle","filter","Boolean","output","w","test","exec","processWord","e","console","error","then","bind","_ref","words"],"mappings":"yFAAAA,EAAAC,EAAAC,GAAAF,EAAAG,EAAAD,EAAA,+BAAAE,IAAA,IAAAC,EAAAL,EAAA,GAMIM,EAAU,GAkEP,SAASF,IAAuB,IAAZG,EAAYC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAJ,GAClC,IACC,OAAOD,EACLI,MAAM,KACNC,IAAI,SAAAC,GAAM,OAzDd,WAAoC,IAAfC,EAAeN,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAJ,GAEzBD,EAAQO,EAASH,MAAM,KAAKI,KAAK,IAGjCC,EAAK,IAAIC,OAAJ,IAAAC,OAENX,EAEFI,MAAM,IAENC,IACA,SAAAO,GAAG,OACDA,EAAMC,SAASD,EAAK,MACrBA,GAAO,GACPA,GAAO,GAFP,IAAAD,OAGIG,IAAKF,EAAM,GAAGG,SAHlB,OAMDC,OAAOC,SAGPT,KAAK,IAjBG,KAkBV,KAIKU,EAASnB,EAIbiB,OAAO,SAAAG,GAAC,OAAIA,EAAEjB,SAAWF,EAAME,SAE/Bc,OAAO,SAAAG,GAAC,OAAIV,EAAGW,KAAKD,KAGtB,OAAKD,EAAOhB,OASLgB,EAJO,kBAAkBG,KAAKd,GAAU,GAAGL,OAI5BgB,EAAOhB,QARrBF,EAoBSsB,CAAYhB,KAC1BE,KAAK,KACN,MAAOe,GAER,OADAC,QAAQC,MAAMF,GACP,IAxET9B,EAAA8B,EAAA,GAAAG,KAAAjC,EAAAkC,KAAA,UAAkDD,KACjD,SAAAE,GAAA,IAAGC,EAAHD,EAAGC,MAAH,OAAgB9B,EAAU8B,EAAMzB,MAAM","file":"static/js/server.387ccc1b.chunk.js","sourcesContent":["import { keys } from '../constants';\n\n/**\n * Available dictionary of words\n * @type {Array<String>}\n */\nlet wordMap = [];\n// Split the words module into a separate chunk\nimport(/* webpackChunkName: \"words\" */ './words').then(\n\t({ words }) => (wordMap = words.split('\\n'))\n);\n\n/**\n * Process a single word\n * Find matches in the dictionary and return one match,\n * If there are no matches, return the input\n * @param  {String} rawInput Raw input, including * characters\n * @return {String}          Processed word\n */\nfunction processWord(rawInput = '') {\n\t// Normalize input by removing all * characters\n\tconst input = rawInput.split('*').join('');\n\n\t// Construct RegExp to find matching words\n\tconst re = new RegExp(\n\t\t// Start matching at the beginning of the string (^)\n\t\t`^${input\n\t\t\t// Split string to an array of characters\n\t\t\t.split('')\n\t\t\t// Only process numbers between 2...9\n\t\t\t.map(\n\t\t\t\tnum =>\n\t\t\t\t\t(num = parseInt(num, 10)) &&\n\t\t\t\t\tnum >= 2 &&\n\t\t\t\t\tnum <= 9 &&\n\t\t\t\t\t`[${keys[num - 1].subtitle}]`\n\t\t\t)\n\t\t\t// Discard empty elements\n\t\t\t.filter(Boolean)\n\t\t\t// Join array to be a string\n\t\t\t// Stop matching at the end of the string ($)\n\t\t\t.join('')}$`,\n\t\t'i'\n\t);\n\n\t// Find matching words from the dictionary\n\tconst output = wordMap\n\t\t// For a minimal performance gain,\n\t\t// Filter out any words that aren't\n\t\t// the same length as the input\n\t\t.filter(w => w.length === input.length)\n\t\t// Match the remaining words against the RegExp\n\t\t.filter(w => re.test(w));\n\n\t// If there aren't any matches, return the input string\n\tif (!output.length) {\n\t\treturn input;\n\t}\n\n\t// Find the number of trailing * characters\n\tconst stars = /[0-9]+([*]*)$/gi.exec(rawInput)[1].length;\n\n\t// Return the matched word,\n\t// or alternative match\n\treturn output[stars % output.length];\n}\n\n/**\n * Turn a string of numbers and *'s into words\n * @param  {String} input Input numbers and *'s\n * @return {String}       Output words\n */\nexport function numsToText(input = '') {\n\ttry {\n\t\treturn input\n\t\t\t.split('0')\n\t\t\t.map(inWord => processWord(inWord))\n\t\t\t.join(' ');\n\t} catch (e) {\n\t\tconsole.error(e);\n\t\treturn '';\n\t}\n}\n"],"sourceRoot":""}